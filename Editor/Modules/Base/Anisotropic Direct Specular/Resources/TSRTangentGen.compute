// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel PackTangent


// Default variables needed by the TextureGeneratorControl.
RWTexture2D<float4> Result;
float width;
float height;

struct TextureMetadata
{
	float Width;
    float Height;
    float SelectedChannel;
    float Reverse;
    float Gamma;
};

StructuredBuffer<TextureMetadata> TexturesMeta;
StructuredBuffer<float4> Colors;

// User defined Textures
Texture2D<float4> Tangent;
Texture2D<float4> Anisotropy;

// Converts gamma space to linear space
inline float GammaToLinearSpaceExact (float value)
{
    if (value <= 0.04045F)
    return value / 12.92F;
    else if (value < 1.0F)
    return pow(abs((value + 0.055F))/1.055F, 2.4F);
    else
    return pow(abs(value), 2.2F);
}

// Converts linear space to gamma space
inline float LinearToGammaSpaceExact (float value)
{
    if (value <= 0.0F)
    return 0.0F;
    else if (value <= 0.0031308F)
    return 12.92F * value;
    else if (value < 1.0F)
    return 1.055F * pow(abs(value), 0.4166667F) - 0.055F;
    else
    return pow(abs(value), 0.45454545F);
}

// Select the right channel from the float4
float SelectChannel(float4 tex, float channel)
{
    if(channel == 0)
    {
        return tex.r;
    }
    else if(channel == 1)
    {
        return tex.g;
    }
    else if(channel == 2)
    {
        return tex.b;
    }
    else
    {   
        return tex.a;
    }

}

// If is needed, do the color space correction
float DoColorCorrectionIfNeeded(float gamma, float value)
{
    if(gamma == 1)
    { 
        return LinearToGammaSpaceExact(value);
    }
    else
    {
        return value;
    }
}

float3 DoColorCorrectionIfNeeded(float gamma, float3 value)
{
    if(gamma == 1)
    { 
        return float3(LinearToGammaSpaceExact(value.r), LinearToGammaSpaceExact(value.g), LinearToGammaSpaceExact(value.b));
    }
    else
    {
        return value;
    }
}

// Reverse the value if needed
float DoReverseIfNeeded(float reverse, float value)
{
    if(reverse == 1)
    { 
        return 1 - value;
    }
    else
    {
        return value;
    }
}

float3 DoReverseIfNeeded(float reverse, float3 value)
{
    if(reverse == 1)
    { 
        return 1 - value;
    }
    else
    {
        return value;
    }
}

[numthreads(16,16,1)]
void PackTangent (uint3 id : SV_DispatchThreadID)
{
    // Get the right uv coordinates based on texture size
    float4 pixel = 0;
    float2 uv1 = float2(id.x * TexturesMeta[0].Width / width, id.y * TexturesMeta[0].Height / height);
    float2 uv2 = float2(id.x * TexturesMeta[1].Width / width, id.y * TexturesMeta[1].Height / height);

    // Select the right channel of each texture
    float3 selected1 = Tangent[uv1.xy].rgb;
    float selected2 = SelectChannel(Anisotropy[uv2.xy], TexturesMeta[1].SelectedChannel);

    // Check for color space correction
    selected1 = DoColorCorrectionIfNeeded(TexturesMeta[0].Gamma, selected1);
    selected2 = DoColorCorrectionIfNeeded(TexturesMeta[1].Gamma, selected2);

    // Reverse values where needed
    pixel.rgb = DoReverseIfNeeded(TexturesMeta[0].Reverse, selected1);
    pixel.a = DoReverseIfNeeded(TexturesMeta[1].Reverse, selected2);

    // Return pixel
    Result[id.xy] = pixel;
}
